from pascal_voc_writer import Writer
from PIL import Image, ImageDraw
import json
import os
import xml.etree.ElementTree as ET

def vertices2boundingbox(vertex_list):
    '''Takes a vertex list defining a polygon (list of 2-element coord lists)
    and converts to a bounding box in the form of xmin, ymin, xmax, ymax.
    '''
    xmin = vertex_list[0][0]
    xmax = vertex_list[0][0]
    ymin = vertex_list[0][1]
    ymax = vertex_list[0][1]
    for v in vertex_list:
        xmin = min(xmin, v[0])
        xmax = max(xmax, v[0])
        ymin = min(ymin, v[1])
        ymax = max(ymax, v[1])
    return (xmin, ymin, xmax, ymax)

def generate_VOC_annotations(image_path, polygons_file):
    ''' Takes a json file containing polygons for the images in "image_path"
    and creates xml files in PASCAL VOC format in the "image_path".
    One VOC is generated per image.
    '''
    with open(polygons_file, 'r') as f:
        data=json.load(f)

    for d in data:
        img_path = os.path.join(image_path, d['image'])
        image = Image.open(img_path)
        writer = Writer(image.filename, image.width, image.height)
        for shape in d['shapes']:
            bb = vertices2boundingbox(shape['vertices'])
            writer.addObject(shape['label'], bb[0], bb[1], bb[2], bb[3])
        outpath = str(os.path.splitext(img_path)[0] + '.xml')
        writer.save(outpath)


def parse_VOC(voc_file):
    '''
    Parses a PASCAL VOC annotation file (xml) generated by
    "generate_VOC_annotations" corresponding to one tagged image. Returns a
    dictionary of the following fields:
    image: a filename
    shapes: a list where each item has a label and bounding box in two pairs of
    (xmin, ymin) and (xmax, ymax)
    '''
    tree = ET.parse(voc_file)
    root = tree.getroot()
    image_name = root.find('filename').text
    full_path = root.find('path').text
    d={'image': image_name, 'path': full_path}
    shapelist = []
    for obj in root.findall('object'):
        label = obj.find('name').text
        xmin = int(obj.find('bndbox').find('xmin').text)
        ymin = int(obj.find('bndbox').find('ymin').text)
        xmax = int(obj.find('bndbox').find('xmax').text)
        ymax = int(obj.find('bndbox').find('ymax').text)
        shapelist.append({"label": label, 'bounding_box': [[xmin, ymin], [xmax, ymax]]})
    d['shapes'] = shapelist
    return d

def draw_image_annotations(image_file, voc_file, save=True):
    '''
    draw_image_annotations(image_file, voc_file, save=True)
    Draws bounding boxes around objects tagged in "annotation_file" which is
    expected to be in PASCAL VOC xml format, generated by method
    "generate_VOC_annotations".
    If the "save" flag is true, the result is saved in the same directory as the
    original image file with "_annotated" added to the filename. Otherwise, the
    result is rendered via the Image.show() method of the PIL library:
    https://pillow.readthedocs.io/en/3.1.x/reference/Image.html#PIL.Image.Image.show
    '''
    data = parse_VOC(voc_file)
    image = Image.open(image_file)
    draw = ImageDraw.Draw(image)
    for shape in data['shapes']:
        draw.rectangle( [shape['bounding_box'][0][0], shape['bounding_box'][0][1], shape['bounding_box'][1][0], shape['bounding_box'][1][1]], outline=128, width=3)
    if save:
        filepath, extension = os.path.splitext(data['path'])
        image.save(filepath + '_annotated' +extension)
    else:
        image.show()


def crop_image(image_file, voc_file, x, y, width, height, output_directory):
    '''
    crop_image(image_file, voc_file, x, y, width, height, output_directory):
    Crops the image file defined in the passed "voc_file", expected to be in
    PASCAL VOC xml format, generated by method "generate_VOC_annotations".
    The cropped image has top left at passed "x", "y" and dimensions of passed
    "width", "height". If the image is not large enough for either width or
    height, it is cropped up to its maximum dimensions.
    The resulting cropped image and its associated annotations file in PASCAL
    VOC xml format are saved in passed "output_directory".
    '''
    if not os.access(output_directory,  os.W_OK):   # check output dir exists and we can write to it
        print("Error: cannot write to directory: " + output_directory)
        return
    data = parse_VOC(voc_file)
    image_name, extension = os.path.splitext(os.path.basename(image_file))
    output_image_filepath = os.path.join(output_directory, image_name + '_cropped' + extension)
    output_annot_filepath = os.path.join(output_directory, image_name + '_cropped' + '.xml')
    if os.path.isfile(output_image_filepath):
        print("Error: file already exists: " + output_image_filepath)
        return
    if os.path.isfile(output_annot_filepath):
        print("Error: file already exists: " + output_annot_filepath)
        return
    # Reaching here means we have done our file and path tests and we are OK to write our outputs
    # First we do the image file
    image = Image.open(data['path'])
    x2 = min(image.width, x+width)
    y2 = min(image.height, y+height)
    imc=image.crop((x, y, x2, y2))
    imc.save(output_image_filepath, quality=95)
    print('Saved image: ' + output_image_filepath)
    # Then we do the annotation file
    writer = Writer(output_image_filepath, imc.width, imc.height)
    for shape in data['shapes']:
        bb = shape['bounding_box']
        bb[0][0] = bb[0][0] - x
        bb[0][1] = bb[0][1] - y
        bb[1][0] = bb[1][0] - x
        bb[1][1] = bb[1][1] - y
        if bb[0][0] < 0 or bb[0][0] > width:
            continue
        if bb[0][1] < 0 or bb[0][1] > height:
            continue
        if bb[1][0] < 0 or bb[1][0] > width:
            continue
        if bb[1][1] < 0 or bb[1][1] > height:
            continue
        writer.addObject(shape['label'], bb[0][0], bb[0][1], bb[1][0], bb[1][1])
    writer.save(output_annot_filepath)
    print("Saved annotation file: " + output_annot_filepath)

def get_image_ROI(voc_file):
    '''
    Given passed annotation file "voc_file", expected to be in PASCAL VOC xml
    format, generated by method "generate_VOC_annotations", gets the
    "bounding box of bounding boxes", i.e. the outer limits of tagged items in
    the image.
    '''
    data = parse_VOC(voc_file)
    xmax = data['shapes'][0]['bounding_box'][0][0]
    ymax = data['shapes'][0]['bounding_box'][0][1]
    xmin = data['shapes'][0]['bounding_box'][0][0]
    ymin = data['shapes'][0]['bounding_box'][0][1]
    for shape in data['shapes']:
        for point in shape['bounding_box']:
            xmax = max(point[0], xmax)
            xmin = min(point[0], xmin)
            ymax = max(point[1], ymax)
            ymin = min(point[1], ymin)
    return [[xmin, ymin], [xmax, ymax]]
